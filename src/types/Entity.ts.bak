/**
    这个方案有递归，ts处理不了，要简化
    by Xc 20220202
**/
import { GenericAction } from '../actions/action';
import { DataTypes } from './DataType';
import { FnCallFilter, FnCallProjection, FnCallSorter, FulltextFilter, MakeFilter, Q_BooleanValue, Q_NumberValue, Q_StringValue } from './Demand';
import { OneOf } from './Polyfill';

export type Filter<A extends string, F extends Object | undefined = undefined> = {
    id?: A extends 'create' ? undefined : string;
    ids?: undefined;
    filter?: undefined;
    indexFrom?: undefined;
    count?: undefined;
} | {
    id?: undefined;
    ids?: A extends 'create' ? undefined : string[];
    filter?: undefined;
    indexFrom?: undefined;
    count?: undefined;
} | {
    id?: undefined;
    ids?: undefined;
    filter?: A extends 'create' ? undefined : F;
    indexFrom?: A extends 'create' ? undefined : number;
    count?: A extends 'create' ? undefined : number;
};

type SelectOption = {
    forUpdate?: true;
    usingIndex?: 'todo';
};

export type Operation<A extends GenericAction | string,
    DATA extends Object,
    FILTER extends Object | undefined = undefined,
    SORTER extends Object | undefined = undefined> = {
        action: A;
        data: DATA;
        sorter?: SORTER;
        option?: A extends 'select' ? SelectOption : undefined;
    } & Filter<A, FILTER>;

export type Selection<DATA extends Object, FILTER extends Object | undefined = undefined, SORT extends Object | undefined = undefined> = Operation<'select', DATA, FILTER, SORT>;

export interface EntityDef<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}, T extends E> {
    // Name: T;
    Schema: {
        id: string;
        $$createAt$$?: number | Date;
        $$updateAt$$?: number | Date;
    } & {
        [A: string]: DataTypes | EntityDef<E, ED, E>['Schema'] | Array<EntityDef<E, ED, E>['Schema']>;
    };
    OpSchema: {
        [A in keyof EntityDef<E, ED, T>['Schema']]: DataTypes;
    };
    Action: string;
    ParticularAction?: string;
};

type DeduceProjection<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}, T extends E> = {
    [K in keyof ED[T]['OpSchema']]?: 1;
} & {
    [K in keyof ED[T]['Schema']]?: DeduceProjection<E, ED, E>;
} & {
    [F: string]: EntityDesc<E, ED, E>['Selection'];
} & FnCallProjection<keyof EntityDef<E, ED, T>['OpSchema']>;

type DeduceFilter<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}, T extends E> = MakeFilter<{
    [K in keyof EntityDef<E, ED, T>['OpSchema']]: Q_NumberValue | Q_StringValue | Q_BooleanValue | {
        [K in '$in' | '$nin']: EntityDesc<E, ED, E>['Selection'];
    };
} & FnCallFilter & FulltextFilter>;

type DeduceSorterAttr<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}, T extends E> = OneOf<{
    [A in keyof EntityDef<E, ED, T>['Schema']]: 1 | Object;
} & FnCallSorter>;

type DeduceSorter<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}, T extends E> = Array<{
    $attr: DeduceSorterAttr<E, ED, T>;
    $direction?: "asc" | "desc";
}>;

type DeduceSelection<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}, T extends E> = Selection<DeduceProjection<E, ED, T>, DeduceFilter<E, ED, T>, DeduceSorter<E, ED, T>>;

type DeduceCreateOperationData<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}, T extends E> = EntityDef<E, ED, T>['OpSchema'] & {
    [A in keyof EntityDef<E, ED, T>['Schema']]?: DeduceCreateSingleOperation<E, ED, E> | DeduceUpdateOperation<E, ED, E> & {
        id: string;
    } | undefined | string;
} & {
    [A: string]: DeduceCreateOperation<E, ED, E> | DeduceUpdateOperation<E, ED, E>;
};

type DeduceCreateSingleOperation<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}, T extends E> = Operation<'create', DeduceCreateOperationData<E, ED, T>>;

type DeduceCreateMultipleOperation<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}, T extends E> = Operation<'create', Array<DeduceCreateOperationData<E, ED, T>>>;

type DeduceCreateOperation<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}, T extends E> = DeduceCreateSingleOperation<E, ED, T> | DeduceCreateMultipleOperation<E, ED, T>;

type DeduceUpdateOperationData<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}, T extends E> = Partial<Omit<EntityDef<E, ED, T>['OpSchema'], 'id'>> & {
    [A in keyof EntityDef<E, ED, T>['Schema']]?: DeduceCreateSingleOperation<E, ED, E> |
    Omit<DeduceUpdateOperation<E, ED, E>, 'id' | 'ids' | 'filter'> |
    undefined | string;
} & {
    [A: string]: DeduceCreateOperationData<E, ED, T> | Omit<DeduceUpdateOperation<E, ED, E>, 'id' | 'ids' | 'filter'>;
};

type DeduceUpdateOperation<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}, T extends E> = Operation<EntityDef<E, ED, T>['ParticularAction'] extends string ? 'update' | EntityDef<E, ED, T>['ParticularAction'] : 'update', DeduceUpdateOperationData<E, ED, T>>;

type DeduceRemoveOperationData<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}, T extends E> = {
    [A in keyof EntityDef<E, ED, T>['Schema']]?: Omit<DeduceUpdateOperation<E, ED, E> | DeduceRemoveOperation<E, ED, E>, 'id' | 'ids' | 'filter'>;
} & {
    [A : string]: Omit<DeduceUpdateOperation<E, ED, E> | DeduceRemoveOperation<E, ED, E>, 'id' | 'ids' | 'filter'>;
};

type DeduceRemoveOperation<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}, T extends E> = Operation<'remove', DeduceRemoveOperationData<E, ED, T>>;

type DeduceOperation<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}, T extends E> = DeduceCreateOperation<E, ED, T> | DeduceUpdateOperation<E, ED, T> | DeduceRemoveOperation<E, ED, T>;


export interface EntityDesc<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}, T extends E> extends EntityDef<E, ED, T> {
    Selection: DeduceSelection<E, ED, T>;
    Operation: DeduceOperation<E, ED, T>;
    FetchRow: {
        data: DeduceProjection<E, ED, T>;
        ids: string[];
        sorter: DeduceSorter<E, ED, T>;
    };
};

export interface OperationResult<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}> {
    operations?: {                                          // cud返回的结果，select也有可能返回
        [T in E]: Array<EntityDesc<E, ED, T>['Operation']>;
    };      // create/update/remove返回的动作结果
    stats?: 'todo';
    errors: Array<{
        code?: number;
        message: string;
    }>;
};

export interface SelectionResult<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}> extends OperationResult<E, ED> {
    ids: string[];
}

export type FetchRowResult<E extends string, ED extends {
    [K in E]: EntityDef<E, ED, K>;
}, T extends E> = Array<EntityDef<E, ED, T>['Schema']>;
